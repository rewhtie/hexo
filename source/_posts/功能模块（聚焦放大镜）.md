---
title: 聚焦放大镜
date: 2023-06-08 12:00
tags:
  - 功能模块
---

实现一个窗口拖拽移动并且能自由拉伸宽高的元素区域，区域内的元素根据比例放大

<!-- more -->

### 1.实现效果

![聚焦效果动画](http://linmingqi.top/img/%E8%81%9A%E7%84%A6%E6%94%BE%E5%A4%A7%E5%8A%A8%E7%94%BB.gif)

### 2.弄清本质

>技术点

<font color="red">1.放大元素节点通过 querySelector 选择到节点 cloneNode克隆</font>

```ts
const baseView = document.querySelector(`#base-view`) as HTMLDivElement
const screenSlide = baseView.querySelector('.current') as HTMLDivElement
const nodeViewRef = screenSlide.cloneNode(true) as HTMLDivElement
```
<font color="red">2.useElementSize, useMouseInElement</font>  [详情查看vueuse官网](http://www.vueusejs.com/core/useElementSize/)
useElementSize：实时获取元素的宽高
useMouseInElement：实时获取鼠标是否在元素内

>关键点

<font color="red">1.拖拽移动公式</font>
- 放大节点元素定位在放大窗口，默认是left：0；top：0
- 放大窗口定位在浏览器窗口，默认是left：0；top：0
- 两者移动过程，一个是（放大窗口）向右下移动的过程（相对浏览器窗口）；一个是（放大节点）向左上移动的过程（相对放大窗口）

<font color="red">2.例如：放大窗口 left： 200px ， 放大节点 left： -200px</font>
<font color="red">3.以上代入移动公式：</font>
- 放大节点left: left = -（ 放大倍数 * 浏览器满屏幕宽度 ）+ 放大窗口宽度 / 2 / 放大倍数
- 放大节点top：同理

<font color="red">4.有时候你的放大区域并需要覆盖到整个浏览器窗口，只需要一小区域，这时候 浏览器各项的值 替换成 一小区域内的 值</font>

### 3.最基础的html实现代码(直接复制打开)

```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>DEMO | 图片放大器</title>
		<style>
      body,
      html {
        height: 100%;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
        position: relative;
        min-width: 700px;
        background: rgb(202, 201, 201);
      }

      .container {
        width: 650px;
        height: 400px;
        background: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 5px solid rgb(244, 254, 255);
      }

      #lens {
        position: absolute;
        border: 2px solid grey;
        border-radius: 50%;
        overflow: hidden;
        cursor: none;
        box-shadow: inset 0 0 10px 2px grey;
        filter: drop-shadow(0 0 2px grey);
      }

      #zoom img {
        width: 650px;
        height: 400px;
      }

      #lens > * {
        cursor: none;
      }

      @media (max-height: 600px) {

        #zoom img,
        .container {
          width: 520px;
          height: 330px;
        }
      }
      .page-footer {
        position: fixed;
        right: 35px;
        bottom: 20px;
        display: flex;
        align-items: center;
        padding: 5px;
        color: black;
        background: rgba(255, 255, 255, 0.65);
      }

      .page-footer a {
        display: flex;
        margin-left: 4px;
      }
      .touxiang {
        bottom: 0;
        width: 30px;
        height: 30px;
      }
		</style>
	</head>
	<body>
		<div class="container">
			<div id="zoom">
				<img src="https://dev2.midiplusedu.com/storage/public:MjAyMy8wNS8xNi9yY04xWWRqRU9zb1c5c1kyZmV4TDg1Rk82NkFsdkZ3cjF5RExqbUJXejRRM2FmQTdZbzhMMFdrdXZjV0s0bHFvLnBuZw==" alt="">
			</div>
		</div>
		<script>
			const lensSize = { w:290, h:200 };

			function magnify(id, zoom) {
				const el = document.getElementById(id);
				const copy = el.cloneNode(true);
				const lens = document.createElement("div");

				lens.setAttribute("id", "lens")
				lens.style.width = lensSize.w + "px";
				lens.style.height = lensSize.h + "px";

				el.appendChild(lens);
				el.getBoundingClientRect();
				copy.style.zoom = zoom;
				lens.appendChild(copy);

				copy.style.width = (el.offsetWidth * copy.style.zoom) + "px";
				copy.style.heigth = (el.offsetHeight * copy.style.zoom) + "px";
				copy.style.position = "absolute";

				el.addEventListener("mousedown", (ev) => {
					ev.preventDefault();
					ev.stopPropagation();
          setTimeout(()=>{
            document.onmousemove = (ev) => {
              const pos = getCursorPos(ev);
              console.log(ev.pageX, ev.pageY, el.offsetLeft, el.offsetTop)
              lens.style.left = -(lensSize.w / 2) + pos.x + "px";
              lens.style.top = -(lensSize.h / 2) + pos.y + "px";
              copy.style.left = -(pos.x - el.offsetLeft) + (lensSize.w / copy.style.zoom) * 0.5 + "px";
              copy.style.top = -(pos.y - el.offsetTop) + (lensSize.h / copy.style.zoom) * 0.5 + "px";
            }
          },100)
				})
        el.addEventListener('mouseup', (ev) => {
          document.onmousemove = null
        })
			}

			function getCursorPos(e) {
        // console.log(event,  window.event,'------')
				// var x = (window.Event) ? e.pageX : event.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft :
				// document.body.scrollLeft);
				// var y = (window.Event) ? e.pageY : event.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop :
				// document.body.scrollTop);
				return {
					x: e.pageX,
					y: e.pageY
				};
			}
			magnify("zoom", 2)
      
		</script>
	</body>
</html>
```

### 4.Vue3具体实现代码

<font color="#08c">vue3 + ts + windicss + vueuse 实现组件封装</font>

#### template
```html
<!-- 浏览器窗口盖一层蒙版层，层级最高 -->
  <div class="zoom-draw" :style="drawStyle">
    <!-- 放大移动区域 -->
    <div class="zoom-lens" ref="lenRef" :style="lenStyle" @mousemove="handleMouseMove" @mousedown="dragging = true" @mouseup="dragging = false, noMove = false, zoneSticks = false">
      <!-- 需要放大的元素，需要获取节点v-html回显 -->
      <div _pos="absolute" class="w-pointer-events-none" :style="zommStyle" v-html="nodeRef?.outerHTML"></div>
    </div>
    <!-- 操作按钮区域 -->
    <div _pos="absolute" _display="flex" :style="areaStyle" _flex="items-center justify-center" >
      <div class="zoom-area" _flex="~" _border="rounded-l-lg rounded-r-lg" _cursor="pointer">
        <button class="area-button" _w="50px" _cursor="pointer" _bg="white" _border="none rounded-l-lg"  _h="40px"  _display="flex" _flex="items-center justify-center" @click="zoomInMove('+')">
          <iconpark-icon name="Vector"></iconpark-icon>
        </button>
        <button class="area-button" _w="50px" _cursor="pointer" _bg="white" _border="none" _h="40px" _display="flex" _flex="items-center justify-center" @click="zoomInMove('-')">
          <iconpark-icon name="Vector-3"></iconpark-icon>
        </button>
        <button class="area-button" _w="50px" _cursor="pointer" _bg="white" _border="none" _h="40px" _display="flex" _flex="items-center justify-center" @click="zoomMask">
          <iconpark-icon name="Opportunity-1"></iconpark-icon>
        </button>
        <button class="area-button" _w="50px" _cursor="pointer" _bg="white" _border="none rounded-r-lg" _h="40px" _display="flex" _flex="items-center justify-center" @click="emit('close')">
          <iconpark-icon name="circle-close"></iconpark-icon>
        </button>
      </div>
    </div>
    <!-- 拉伸操作区域的角落方形区域，类似截图工具 -->
    <div _z="10" _pos="absolute" v-for="(stick, index) in sticks" :key="index" :style="{ ...zoneStyle[stick], width: zoneSize + 'px', height: zoneSize + 'px' }" 
      @mouseup.stop="zoneSticks = false" 
      @mousedown.stop="zoneSticks = true" 
      @mousemove.stop="handleZoneMove($event, stick)"
      @mouseleave.stop="zoneSticks = false"
    ></div>
  </div>
```

#### srcript
```ts
import { ref, computed, onMounted, watch, nextTick } from 'vue'
import { useElementSize, useMouseInElement } from '@vueuse/core'

const emit = defineEmits<{
  (event: 'close'): void
}>()

const props = defineProps({
  node: {
    /*
    **需要放大的克隆节点,利用cloneNode克隆元素
    **nextTick(() => {
        const baseView = document.querySelector(`#base-view`) as HTMLDivElement
        const screenSlide = baseView.querySelector('.current') as HTMLDivElement
        nodeViewRef.value = screenSlide.cloneNode(true) as HTMLDivElement
      })
    */
    required: true,
  },
  scale: {
    required: true,
    type: Number
  }
})
const nodeRef = ref() //放大节点
const lenRef = ref() //放大窗口节点
const element = useElementSize(lenRef) //获取放大窗口的实时宽高
const isOutside = useMouseInElement(lenRef) //获取鼠标是否在放大窗口的区域内
const width = ref<number>(450) //放大区域原始宽度
const height = ref<number>(300) //放大区域原始高度
const left = ref<number>(0) //放大区域原始left
const top = ref<number>(0) //放大区域原始top

const zoomWidth = ref<number>(450) //放大节点宽度
const zoomHeight = ref<number>(300) //放大节点高度
const zoomLeft = ref<number>(0) //放大节点定位
const zoomTop = ref<number>(0) //放大节点定位
const zoomSize = ref<number>(1) //放大倍数
const max = 2.5 //最大放大倍数
const min = 1 //最小倍数

// const sticks = ['tl', 'tm', 'tr', 'mr', 'br', 'bm', 'bl', 'ml'] 
/* 
**拉伸区域，表示 b底 r右 l左 t顶 m中, 这里只展示左边中间、底下中间跟右下角
**右中：拉伸宽度、定位不变
**底中：拉伸高度、定位不变
**右下角：同事拉伸宽高度、定位不变
**左中：拉伸宽度、目前定位（需要记录元素最右边的边边到窗口的距离）减去扩大的宽度
*/ 
const sticks = ['br', 'mr', 'bm']
const zoneSize = 35 // 拉伸区域宽高，最好大点，不然鼠标移动过快压根移不动
const zoneSticks = ref<boolean>(false) //表示拉伸区域已被长按触发

// 放大窗口是否能拖拽移动
const dragging = ref(false as boolean)

// 鼠标的位置
const movePostion = ref({
  x: 0,
  y: 0
})

watch(() => props.node, () => {
  // 获取节点赋值
  nodeRef.value = props.node
})

// 表示已经进入放大窗口元素内，可以拖拽移动了，顺便把鼠标样式改成手掌，计算属性lenStyle已经实现
watch(() => isOutside, (value) => {
  dragging.value = value ? true : false
})

const maskBackground = ref<string>('rgba(0,0,0,0)') //背景模糊变暗


// 开关灯样式控制
const drawStyle = computed(() => {
  return {
    background: `${maskBackground.value}`
  }
})

/* 
**可拉伸的区域元素在放大窗口各个角落
**占据角落1/2的位置，与放大窗口边框重叠，层级肯定在上面，类似截图工具之类的边边方形
*/
const zoneStyle = computed(() => {
  return {
    tl: {
      left: left.value - zoneSize / 2 + 'px',
      top: top.value - zoneSize / 2 + 'px',
      cursor: 'nw-resize'
    }, 
    tm: {
      left: left.value + width.value / 2 + 'px',
      top: top.value - zoneSize / 2 + 'px',
      cursor: 'n-resize'
    }, 
    tr: {
      left: left.value + width.value - zoneSize / 2 + 'px',
      top: top.value - zoneSize / 2 + 'px',
      cursor: 'ne-resize'
    }, 
    mr: {
      left: left.value + width.value - zoneSize / 2 + 'px',
      top: top.value + height.value - zoneSize / 2 + 'px',
      cursor: 'nw-resize',
    }, 
    br: {
      left: left.value + width.value - zoneSize / 2 + 'px',
      top: top.value + height.value / 2 - zoneSize / 2 + 'px',
      cursor: 'e-resize'
    }, 
    bm: {
      left: left.value + width.value / 2 - zoneSize / 2 + 'px',
      top: top.value + height.value - zoneSize / 2 + 'px',
      cursor: 'n-resize'
    }, 
    bl: {
      left: left.value - zoneSize / 2 + 'px',
      top: top.value + height.value / 2 - zoneSize / 2 + 'px',
      cursor: 'e-resize'
    }, 
    ml: {
      left: left.value - zoneSize / 2 + 'px',
      top: top.value + height.value - zoneSize / 2 + 'px',
      cursor: 'ne-resize'
    }
  }
})

/*
**放大窗口样式
*/
const lenStyle = computed(() => {
  return {
    width: `${width.value}px`,
    height: `${height.value}px`,
    left: `${left.value}px`,
    top: `${top.value}px`,
    cursor: dragging.value ? 'grabbing' : 'grab', // 在元素内：长按拖拽的时候鼠标样式是拳头、松开是手掌
    resize: noMove.value ? 'auto' : 'none', // resize是个强大的css属性，实现拉伸，但是直接使用会跟拖拽事件重叠，所以只能抛弃，这里忽略
    // border: noMove.value ? '2px dashed #ff5e2a' : 'none',
    border: '2px dashed #ff5e2a'
  }
})

/*
**操作按钮样式
*/
const areaStyle = computed(() => {
  return {
    width: `${width.value}px`,
    left: `${left.value}px`,
    top: `${top.value + height.value}px` //因为操作按钮是一直跟着放大窗口底下的，所以要 + 放大窗口的高度
    // top: `${top.value + height.value + zoneSize / 2 + 5}px`
  }
})

/*
**放大的节点样式
*/
const zommStyle = computed(() => {
  return {
    width: `${zoomWidth.value}px`,
    height: `${zoomHeight.value}px`,
    left: `${zoomLeft.value}px`,
    top: `${zoomTop.value}px`,
    zoom: `${zoomSize.value}`,

    // 这里很炒蛋，因为我外层的元素已经被transform：scale放大过了，克隆到的元素是1：1的，我们也需要手动给他放大
    transform: `scale(${ zoomSize.value === 1 ? 1 : props.scale})`,
  }
})

const getCursorPos = (e: MouseEvent) => {
  // 获取鼠标在视图的位置~记录最后一次
  movePostion.value.x = e.pageX
  movePostion.value.y = e.pageY
  return {
    x: e.pageX,
    y: e.pageY
  }
}

// 拉伸放大窗口，放大窗口实时变化宽度高度
const handleZoneMove = (ev: MouseEvent, type: string) => {
  if (!zoneSticks.value) return
  switch (type) {
    // 左上角
    case 'tl':
      
      break
    //   中上角
    case 'tm':
      break
    // 右上角
    case 'tr': 
      
      break
    // 中间右边
    case 'mr':
      width.value = ev.pageX - left.value 
      height.value = ev.pageY - top.value
      break
    // 右下角
    case 'br': 
      width.value = ev.pageX - left.value 
      break
    // 中下角
    case 'bm':
      height.value = ev.pageY - top.value
      break
    // 左下角
    case 'bl': 
      width.value += ev.pageX - left.value
      left.value = ev.pageX
      break
    //   中间左边
    case 'ml':
    
      break
    default:
  }
}

// 控制放大、缩小
const zoomInMove = (type: string) => {
  if (type === '+') {
    if (zoomSize.value >= max) return
    zoomSize.value = zoomSize.value === 1 ? 1.6 : zoomSize.value + 0.3
  } 
  else {
    if (zoomSize.value <= min) return
    zoomSize.value -= 0.3
  }
  
  zoomSizeUpdate(movePostion.value)
}

// 是否开关灯、除放大区域外背景模糊变暗
const zoomMask = () => {
  if (maskBackground.value === 'rgba(0, 0, 0, 0.9)') maskBackground.value = 'rgba(0, 0, 0, 0)'
  else maskBackground.value = 'rgba(0, 0, 0, 0.9)'
}

// 鼠标移动
const handleMouseMove = (ev: MouseEvent) => {
  if (noMove.value) return
  if (!dragging.value) return
  const pos = getCursorPos(ev)

  /*
  **保持移动鼠标时永远在移动区域内最中心处
  */
  left.value = -(width.value / 2) + pos.x
  top.value = -(height.value / 2) + pos.y

  // left.value = pos.x
  // top.value = pos.y
  zoomSizeUpdate(pos)
}


// 更新放大位置，放大窗口做拖拽移动操作、拉伸宽高操作
const zoomSizeUpdate = (pos: { x: number, y: number }) => {

  //元素是占满整个屏幕的，所以这里直接获取宽高*放大倍数，实现之后的宽高
  zoomWidth.value = document.body.clientWidth * zoomSize.value
  zoomHeight.value = document.body.clientHeight * zoomSize.value

  switch (zoomSize.value) {
    // case 1:
    //   zoomLeft.value = -(pos.x) + (width.value / 2 / zoomSize.value) - document.body.clientWidth
    //   zoomTop.value = -(pos.y) + (height.value / 2 / zoomSize.value) - document.body.clientHeight
    //   break
    // case 1.5:
    //   zoomLeft.value = -(pos.x) + (width.value / 2 / zoomSize.value) - document.body.clientWidth / 3.7
    //   zoomTop.value = -(pos.y) + (height.value / 2 / zoomSize.value) - (document.body.clientHeight - height.value * 2.5)
    //   break
    // case 2:
    //   zoomLeft.value = -(pos.x) + (width.value / 2 / zoomSize.value) - document.body.clientWidth / 2
    //   zoomTop.value = -(pos.y) + (height.value / 2 / zoomSize.value) - (document.body.clientHeight - height.value * 2)
    //   break
    // case 2.5:
    //   zoomLeft.value = -(pos.x) + (width.value / 2 / zoomSize.value) - document.body.clientWidth / 1.3
    //   zoomTop.value = -(pos.y) + (height.value / 2 / zoomSize.value) - (document.body.clientHeight - height.value * 1.2)
    //   break
    // case 3:
    //   zoomLeft.value = -(pos.x) + (width.value / 2 / zoomSize.value) - document.body.clientWidth
    //   zoomTop.value = -(pos.y) + (height.value / 2 / zoomSize.value) - (document.body.clientHeight - height.value * 0.2)
    //   break
    default:
      /*
      **放大节点，在放大窗口默认是left：0，top：0位置，所以放大窗口往右拖拽的时候，放大节点对于放大窗口是做left：-的运动
      **例如：放大窗口相对窗口 向右移动200px， 放大节点相对放大窗口 向左移动200px，是做相反的运动
      **注意：这里还需要加上放大窗口本身 1/2 的宽度 才能对准位置，为什么是 1/2?
      */
      zoomLeft.value = -(zoomSize.value * pos.x) + (width.value / 2 / zoomSize.value)
      zoomTop.value = -(zoomSize.value * pos.y) + (height.value / 2 / zoomSize.value)
  }
}

onMounted(() => {
  // 页面刷新需要调整位置
  nextTick(() => {
    zoomSizeUpdate({ x: width.value / 2, y: height.value / 2 })
  })
})
    
```

#### style
```css
/* 视图窗口蒙版层 */
.zoom-draw {
  width: 100vw;
  height: 100vh;
  position: fixed;
  border: 0;
  z-index: 99;
  top: 0;
  left: 0;
}
/* 放大区域 */
.zoom-lens {
  width: 450px;
  height: 300px;
  filter: drop-shadow(grey 0 0 2px);
  box-shadow: grey 0 0 10px 2px inset;
  position: fixed;
  overflow: hidden; /*超出放大窗口之外隐藏*/
  z-index: 9;
  left: 214px;
  top: 282px;
}
/* 按钮区域 */
.zoom-area {
  box-shadow: 0 2px 12px 0 rgb(56 56 56 / 20%);
  .area-button:focus {
    background: #ff5e2a;
    color: #ebebeb;
  }
}
```

<!-- more -->