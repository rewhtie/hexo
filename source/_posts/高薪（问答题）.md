
---
title: 问答题
tags:
  - 高薪之路
categories: 知识点
---

最接近的一次机会,要好好把握住呀

<!-- more -->

#### 1.Http的请求方式有哪些?

| 方法    | 描述                                  |
| ------- | ------------------------------------- |
| get     | 查                                    |
| head    | get相同，返回http报头，不反悔具体内容 |
| post    | 增                                    |
| put     | 主要用来传输文件（改）                |
| delete  | 删                                    |
| options | 请求的指定资源都支持什么http方法      |

```js
1.GET在浏览器回退时是无害的，而POST会再次提交请求。
2.GET比POST更不安全，因为参数直接暴露在URL上（POST放在Request body中），所以不能用来传递敏感信息。
```



#### 2.Http请求中Content-Type和cache-control的作用是?

Cache-Control 可缓存性 no-cache可以在本地进行缓存，每次请求都要向服务器验证，服务器允许，才能本地缓存

​	第一部分General是概要，包含请求地址，请求方式，[状态码](https://so.csdn.net/so/search?q=状态码&spm=1001.2101.3001.7020)，服务器地址以及Referrer 策略。
​	第二部分是应答头部，是服务器返回的。
​	第三部分是请求头部，是客户端发送的。

Content-Type，内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件

```js
1.application/x-www-form-urlencoded 浏览器原生表单
2.multipart/form-data 常见post数据提交
3.application/json 默认的
4.text/xml
5.multipart/form-data 表单提交
```



#### 3.WEB应用从服务器主动推送Data到客户端有那些方式?哪些是你用过的?

```js
ajax
和
WebSocket 握手链接没用过
```

#### 4.请简单说明UTF-7,UTF-8,UNICODE,BASE64,GB2312的作用和区别?

|            |                                                |
| ---------- | ---------------------------------------------- |
| GB2312     | GBK编码，是在GB2312-80标准基础上的内码扩展规范 |
| base64编码 | 最原始二进制数据流                             |
| UTF-8编码  | 针对不同语言的字符集                           |
| UTF-7编码  | 修改的Base64                                   |
| Unicode    | 将“码位”转换为字节序列的规则，也就是UTF-8编码  |

```
utf-8--------decode(解码)----->>Unicode类型<<-------decode(解码)-----gbk

utf-8<<--------encode(编码)----->>Unicode类型<<-------encode(编码)----->>gbk

utf-8 -> base64(编码) -> ASCII

ASCII -> base64(解码) -> utf-8
```

#### 5.请写出你熟悉的排序算法?

排序大小

```js
points.sort(function(a, b){return a - b}); //从小到大，反过来就是b-a
```

数组反转

```js
reverse()
```

冒泡排序：就是0，1对比；1，2对比；2，3对比，（下标跟下标+1对比）

```js
// 编写方法，实现冒泡
var arr = [29,45,51,68,72,97];
//外层循环，控制趟数，每一次找到一个最大值
for (var i = 0; i < arr.length - 1; i++) {
    // 内层循环,控制比较的次数，并且判断两个数的大小
    for (var j = 0; j < arr.length - 1 - i; j++) {
        // 白话解释：如果前面的数大，放到后面(当然是从小到大的冒泡排序)
        if (arr[j] > arr[j + 1]) {
            var temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }

}
console.log(arr);//[2, 4, 5, 12, 31, 32, 45, 52, 78, 89]
```

选择排序：就是0，1对比；0，2对比；0，3对比，单下标对比多下标

```js
/* 
    选择排序和插入排序特别像，千万不要搞错了
    首先理解双重循环的机制，外层的循环慢于里层的循环，里层循环完才会执行外层
    第一层循环跟里层循环所有+1下标对比，符合就替换位置，这时候替换位置并不会阻碍循环，参于对比的第一个元素已经变了，nums[i]已经不是原来的元素了
    
	例如：原本nums[0]=9，经过对比替换nums[0]=1了，之后对比的都是跟1对比，而不是9
*/
function selectSort(nums) {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            // nums[i] > nums[j]作为一个条件判断，符合两个元素替换位置，这就说明替换之后的元素只会是越来越大的
            if (nums[i] > nums[j]) {
                // 两个元素替换位置
                ;[nums[i], nums[j]] = [nums[j], nums[i]]
            }
        }
    }
}
```

插入排序

```js
/* 
    选择排序和插入排序特别像，千万不要搞错了
    首先理解while，满足条件进入循环
    这里let很关键
*/
function insertSort(nums) {
    for (let i = 1, len = nums.length; i < len; i++) {
        let temp = nums[i]
        while (i >= 0 && temp < nums[i - 1]) {
            nums[i] = nums[i - 1]
            i--
        }
        nums[i] = temp
    }
}
```

#### 6.请用js去除字符串s=" aa bb cc"的空格?

```js
'123 4642 65235 65765 567 5 65 6 50'.replace(/\s*/g,'')
```

或者

```js
let func = (str) => {
    let newStr = '';
    for(let i in str) {
        if(str[i] !== ' ') {
            newStr += str[i];
        }
    }
    return newStr;
}
func(' aa bb cc  ');
```
<!-- more -->