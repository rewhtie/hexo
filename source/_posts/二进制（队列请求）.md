---
layout: post
title: 二进制（队列请求）
data: 2023-08-31 10：51：20
tag: 文件
categories: 函数
---

设计队列导出的实现思路模式

<!-- more -->
#### 一、批量导出

>1.发起多个请求信号，返回信号id
2.根据多个信号id分别请求结果，轮询请求，直到结果返回
难点：轮询接口，可能会重复请求多次

<font size=4 color='#007ACC'>利用递归，实现轮询，新建一个数组，把未返回结果的队列重新添加进去，再一次重新开始队列请求，直到这个队列数组为空</font>

```ts
// 表格勾选多个批量导出
async exportTextbooks() {
	if (this.multipleSelection.length <= 0) {
		this.$message({
			type: 'error',
			message: '请勾选要导出的教材'
		})
		return
	}
	// 页面loading，一般传回调函数一直到结果出现，loading结束
	const loading = this.$loading({
		lock: true,
		text: '导出中',
		spinner: 'el-icon-loading'
	})
	// 先给每个任务发起一个信号，信号队列
	const queueEvents = this.multipleSelection.map(item => {
		return this.$api.resource.exportTextbooks(item.id)
	})
	// 拿到信号队列的结果
	const res = await Promise.all(queueEvents)
	// 执行请求结果队列
	this.exportFileFun(res, loading)
},
```

```ts
async exportFileFun(res, loading) {
	// 新建一个结果队列
	const exportFile = []
	for (const item of res) {
		// 隔断2s请求
		await new Promise(resolve => setTimeout(resolve, 2000))
		// 轮询接口
		const data = await this.$api.resource.exportTextbooksAccept(item.job_id)
		// data.job_status == 2 表示拿到结果
		if (data.job_status == 2) {
			location.href = data.full_url.url;
			// 使用location.href跳转过于频繁会导致只会触发一个，或者被偷吃掉
			await new Promise(resolve => setTimeout(resolve, 500))
		} else {
			exportFile.push({ job_id: item.job_id })
		}
	}
	// 判断队列是否为空，不为空重新执行此方法，为空表示队列下载导出已经全部完成
	if (exportFile.length >= 1) {
		this.exportFileFun(exportFile, loading)
	} else {
		loading.close()
	}
},
```



<!-- more -->